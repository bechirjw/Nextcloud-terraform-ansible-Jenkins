pipeline {
  agent any
triggers {
  cron('''H/5 * * * *
H 9 * * *''')
}

  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time: 20, unit: 'MINUTES')
  }
    parameters {
        // Slack config via params (tu peux aussi les mettre en dur)
    string(name: 'SLACK_TEAM_DOMAIN', defaultValue: 'tonworkspace', description: 'Sous-domaine Slack (ex: monorga)')
    string(name: 'SLACK_CHANNEL', defaultValue: '#jenkins-bot', description: 'Channel Slack ex: #jenkins-bot ou ID Cxxxxxx')


    string(name: 'TARGET_HOST', defaultValue: '127.0.0.1', description: 'H√¥te/VM √† tester (IP publique Azure ou 127.0.0.1 depuis la VM)')
    string(name: 'NC_URL', defaultValue: 'http://127.0.0.1', description: 'URL base Nextcloud (sans /status.php)')
    string(name: 'APACHE_PORT', defaultValue: '80', description: 'Port Apache/PHP')
    string(name: 'PROM_PORT', defaultValue: '9090', description: 'Port Prometheus')
    string(name: 'NODEEXP_PORT', defaultValue: '9100', description: 'Port Node Exporter')
    string(name: 'GRAFANA_PORT', defaultValue: '3000', description: 'Port Grafana')
    string(name: 'JENKINS_PORT', defaultValue: '8081', description: 'Port Jenkins')
    string(name: 'REDIS_HOST', defaultValue: '127.0.0.1', description: 'H√¥te Redis')
    string(name: 'REDIS_PORT', defaultValue: '6379', description: 'Port Redis')
    string(name: 'DB_HOST', defaultValue: '127.0.0.1', description: 'H√¥te MariaDB')
    string(name: 'DB_PORT', defaultValue: '3306', description: 'Port MariaDB')
    string(name: 'DB_USER', defaultValue: 'nextcloud', description: 'Utilisateur DB pour le ping (ex: nextcloud)')
  }
  environment {
    OK   = '\u2705'       // ‚úÖ
    KO   = '\u274C'       // ‚ùå
    WARN = '\u26A0\uFE0F' // ‚ö†Ô∏è
  }
  
  stages {

    stage('Prep: outils pr√©sents ?') {
      steps {
        sh '''
          set -e
          which curl >/dev/null 2>&1 || { echo "Installer curl"; exit 1; }
          which jq   >/dev/null 2>&1 || { echo "Installer jq"; exit 1; }
          which docker >/dev/null 2>&1 || echo "INFO: docker CLI non trouv√© (checks conteneurs limit√©s)."
          which mysql   >/dev/null 2>&1 || which mariadb >/dev/null 2>&1 || echo "INFO: client MySQL non trouv√© (fallback TCP)."
          which redis-cli >/dev/null 2>&1 || echo "INFO: redis-cli non trouv√© (fallback TCP)."
          which column >/dev/null 2>&1 || echo "INFO: 'column' non trouv√© (affichage brut)."
        '''
      }
    }

      stage('Supervision - Sant√© des services') {
        parallel {

          stage('MariaDB') {
            steps {
              script {
                // Attends un Secret Text Jenkins avec ID: db-nextcloud-pass
                withCredentials([string(credentialsId: 'db-nextcloud-pass', variable: 'DB_PASS')]) {
                  def ok = sh(returnStatus: true, script: '''
                    set -e
                    if which mysql >/dev/null 2>&1; then client=mysql; elif which mariadb >/dev/null 2>&1; then client=mariadb; else client=""; fi
                    if [ -n "$client" ] && [ -n "$DB_PASS" ]; then
                      echo "Pinging MariaDB via client..."
                      echo "SELECT 1;" | $client -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -p"${DB_PASS}" >/dev/null
                    else
                      echo "Client ou mot de passe manquant, TCP check via bash..."
                      bash -lc 'exec 3<>/dev/tcp/'"127.0.0.1"'/'"3306"' && exec 3>&-'
                    fi
                  ''') == 0
                  if (!ok) error("${env.KO} MariaDB KO")
                  echo "${env.OK} MariaDB OK"
                }
              }
            }
          }

        stage('PHP/Apache') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://${TARGET_HOST}:${APACHE_PORT}/" >/dev/null
            '''
            echo "${OK} Apache/PHP OK (HTTP 200)"
          }
        }

        stage('Nextcloud status.php') {
          steps {
            sh '''
              set -e
              RESP=$(curl -fsS --max-time 5 "${NC_URL}/status.php" | jq '.installed, .maintenance, .version' -r || true)
              echo "Nextcloud status: ${RESP}"
              curl -fsS --max-time 5 "${NC_URL}/status.php" | jq -e '.installed==true and .maintenance==false' >/dev/null
            '''
            echo "${OK} Nextcloud OK (installed=true, maintenance=false)"
          }
        }

        stage('Redis') {
          steps {
            script {
              def ok = sh(returnStatus: true, script: '''
                set -e
                if which redis-cli >/dev/null 2>&1; then
                  redis-cli -h "${REDIS_HOST}" -p "${REDIS_PORT}" ping | grep -q PONG
                else
                  echo "TCP check via bash pour Redis..."
                  bash -lc 'exec 3<>/dev/tcp/'"${REDIS_HOST}"'/'"${REDIS_PORT}"' && exec 3>&-'
                fi
              ''') == 0
              if (!ok) error("${env.KO} Redis KO")
              echo "${env.OK} Redis OK"
            }
          }
        }

        stage('Docker Daemon') {
          steps {
            script {
              def ok = sh(returnStatus: true, script: 'docker info >/dev/null 2>&1') == 0
              if (!ok) error("${env.KO} Docker KO")
              sh 'docker ps --format "table {{.Names}}\\t{{.Image}}\\t{{.Status}}" || true'
              echo "${env.OK} Docker OK"
            }
          }
        }

        stage('Jenkins (auto-check)') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://4.233.96.230:8080/login" >/dev/null
            '''
            echo "${OK} Jenkins UI OK"
          }
        }

        stage('Node Exporter') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://127.0.0.1:9100/metrics" | head -5
            '''
            echo "${OK} Node Exporter expose les m√©triques"
          }
        }

        stage('Grafana') {
          steps {
            script {
              // Attends un credential "Username with password" ID: grafana-admin
              withCredentials([usernamePassword(credentialsId: 'grafana-admin', usernameVariable: 'GF_USER', passwordVariable: 'GF_PASS')]) {
                def st = sh(returnStatus: true, script: '''
                  set -e
                  curl -fsS --max-time 5 -u "${GF_USER}:${GF_PASS}" "http://127.0.0.1:${GRAFANA_PORT}/api/health" | jq -e '.database=="ok"' >/dev/null
                ''')
                if (st != 0) error("${env.KO} Grafana KO (API health)")
                echo "${env.OK} Grafana OK (API health)"
              }
            }
          }
        }

      } // parallel
    }

    stage('Audit rapide des cibles Prometheus') {
      steps {
        sh '''
          set -e
          echo "Targets summary:"

          # 1) Compter les cibles
          curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
            | jq -r '.data.activeTargets | length | "Active targets: " + tostring'

          # 2) Lister job / health / address
          if which column >/dev/null 2>&1; then
            curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
              | jq -r '.data.activeTargets[] | [.labels.job, .health, .discoveredLabels.__address__] | @tsv' \
              | column -t
          else
            curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
              | jq -r '.data.activeTargets[] | [.labels.job, .health, .discoveredLabels.__address__] | @tsv'
          fi
        '''
        echo "${OK} Audit Prometheus OK"
      }
    }

    stage('Postinstall checks (sanity)') {
      steps {
        sh '''
          echo "Postinstall sanity checks..."
          # Exemple: v√©rifier que les ports attendus √©coutent
          ss -lntp | grep -E ":(${APACHE_PORT}|${PROM_PORT}|${NODEEXP_PORT}|${GRAFANA_PORT}|${JENKINS_PORT})" || true
        '''
        echo "${OK} Postinstall checks termin√©s"
      }
    }
stage('Trivy FS (Nextcloud)') {
  environment {
    NC_DIR        = '/var/www/nextcloud'         // chemin Nextcloud √† scanner
    TRIVY_CACHE   = "${WORKSPACE}/.trivy-cache"  // cache local pour acc√©l√©rer
    REPORT_DIR    = "${WORKSPACE}/trivy-reports"
  }
  steps {
    sh '''
      set -eux

      # Assure les dossiers
      mkdir -p "$TRIVY_CACHE" "$REPORT_DIR"

     

      # Scan lisible (table)
      sudo trivy fs \
        --cache-dir "$TRIVY_CACHE" \
        --scanners vuln,secret,misconfig,license \
        --severity CRITICAL,HIGH \
        --ignore-unfixed \
        --format table \
        "$NC_DIR" | tee "$REPORT_DIR/nextcloud-trivy.txt"

      # Scan JSON (pour post-traitement)
      sudo trivy fs \
        --cache-dir "$TRIVY_CACHE" \
        --scanners vuln,secret,misconfig,license \
        --severity CRITICAL,HIGH \
        --ignore-unfixed \
        --format json \
        --output "$REPORT_DIR/nextcloud-trivy.json" \
        "$NC_DIR"
    '''
  }
  post {
    always {
      archiveArtifacts artifacts: 'trivy-reports/nextcloud-trivy.*', fingerprint: true
    }
  }
}

  }
   // stages

post {
    success {
      withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
        sh '''
          set -e
          # Dossier sentinelle dans le workspace (persistant entre builds)
          mkdir -p ".notify"
          TODAY="$(date -u +%F)"                 # ex: 2025-09-14 (UTC pour coh√©rence)
          FILE=".notify/last_ok_date"

          # Lire la derni√®re date OK (si existe)
          LAST_OK="$( [ -f "$FILE" ] && cat "$FILE" || echo "" )"

          if [ "$LAST_OK" != "$TODAY" ]; then
            # üëâ Premi√®re r√©ussite de la journ√©e: on notifie et on enregistre la date
            payload=$(jq -nc --arg t "‚úÖ all is good for today : ${JOB_NAME} #${BUILD_NUMBER}" '{text:$t}')
            curl -sS -X POST -H 'Content-type: application/json' -d "$payload" "$SLACK_URL"
            echo "$TODAY" > "$FILE"
          else
            echo "Succ√®s d√©j√† notifi√© aujourd'hui ($TODAY). Pas d'envoi Slack."
          fi
        '''
      }
    }
    failure {
      withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
        sh '''
          set -e
          # ‚ö†Ô∏è On notifie √† CHAQUE √©chec
          payload=$(jq -nc --arg t "‚ùå √âCHEC: ${JOB_NAME} #${BUILD_NUMBER} ‚Äî oops failure check Jenkins logs" '{text:$t}')
          curl -sS -X POST -H 'Content-type: application/json' -d "$payload" "$SLACK_URL"
        '''
      }
    }
  }
}// pipeline   