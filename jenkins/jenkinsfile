pipeline {
  agent any
triggers {
  cron('''H/5 * * * *
H 9 * * *''')
}

  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time: 20, unit: 'MINUTES')
  }
    parameters {
        // Slack config via params (tu peux aussi les mettre en dur)
    string(name: 'SLACK_TEAM_DOMAIN', defaultValue: 'tonworkspace', description: 'Sous-domaine Slack (ex: monorga)')
    string(name: 'SLACK_CHANNEL', defaultValue: '#jenkins-bot', description: 'Channel Slack ex: #jenkins-bot ou ID Cxxxxxx')


    string(name: 'TARGET_HOST', defaultValue: '127.0.0.1', description: 'Hôte/VM à tester (IP publique Azure ou 127.0.0.1 depuis la VM)')
    string(name: 'NC_URL', defaultValue: 'http://127.0.0.1', description: 'URL base Nextcloud (sans /status.php)')
    string(name: 'APACHE_PORT', defaultValue: '80', description: 'Port Apache/PHP')
    string(name: 'PROM_PORT', defaultValue: '9090', description: 'Port Prometheus')
    string(name: 'NODEEXP_PORT', defaultValue: '9100', description: 'Port Node Exporter')
    string(name: 'GRAFANA_PORT', defaultValue: '3000', description: 'Port Grafana')
    string(name: 'JENKINS_PORT', defaultValue: '8081', description: 'Port Jenkins')
    string(name: 'REDIS_HOST', defaultValue: '127.0.0.1', description: 'Hôte Redis')
    string(name: 'REDIS_PORT', defaultValue: '6379', description: 'Port Redis')
    string(name: 'DB_HOST', defaultValue: '127.0.0.1', description: 'Hôte MariaDB')
    string(name: 'DB_PORT', defaultValue: '3306', description: 'Port MariaDB')
    string(name: 'DB_USER', defaultValue: 'nextcloud', description: 'Utilisateur DB pour le ping (ex: nextcloud)')
  }
  environment {
    OK   = '\u2705'       // ✅
    KO   = '\u274C'       // ❌
    WARN = '\u26A0\uFE0F' // ⚠️
  }
  
  stages {

    stage('Prep: outils présents ?') {
      steps {
        sh '''
          set -e
          which curl >/dev/null 2>&1 || { echo "Installer curl"; exit 1; }
          which jq   >/dev/null 2>&1 || { echo "Installer jq"; exit 1; }
          which docker >/dev/null 2>&1 || echo "INFO: docker CLI non trouvé (checks conteneurs limités)."
          which mysql   >/dev/null 2>&1 || which mariadb >/dev/null 2>&1 || echo "INFO: client MySQL non trouvé (fallback TCP)."
          which redis-cli >/dev/null 2>&1 || echo "INFO: redis-cli non trouvé (fallback TCP)."
          which column >/dev/null 2>&1 || echo "INFO: 'column' non trouvé (affichage brut)."
        '''
      }
    }

      stage('Supervision - Santé des services') {
        parallel {

          stage('MariaDB') {
            steps {
              script {
                // Attends un Secret Text Jenkins avec ID: db-nextcloud-pass
                withCredentials([string(credentialsId: 'db-nextcloud-pass', variable: 'DB_PASS')]) {
                  def ok = sh(returnStatus: true, script: '''
                    set -e
                    if which mysql >/dev/null 2>&1; then client=mysql; elif which mariadb >/dev/null 2>&1; then client=mariadb; else client=""; fi
                    if [ -n "$client" ] && [ -n "$DB_PASS" ]; then
                      echo "Pinging MariaDB via client..."
                      echo "SELECT 1;" | $client -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -p"${DB_PASS}" >/dev/null
                    else
                      echo "Client ou mot de passe manquant, TCP check via bash..."
                      bash -lc 'exec 3<>/dev/tcp/'"127.0.0.1"'/'"3306"' && exec 3>&-'
                    fi
                  ''') == 0
                  if (!ok) error("${env.KO} MariaDB KO")
                  echo "${env.OK} MariaDB OK"
                }
              }
            }
          }

        stage('PHP/Apache') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://${TARGET_HOST}:${APACHE_PORT}/" >/dev/null
            '''
            echo "${OK} Apache/PHP OK (HTTP 200)"
          }
        }

        stage('Nextcloud status.php') {
          steps {
            sh '''
              set -e
              RESP=$(curl -fsS --max-time 5 "${NC_URL}/status.php" | jq '.installed, .maintenance, .version' -r || true)
              echo "Nextcloud status: ${RESP}"
              curl -fsS --max-time 5 "${NC_URL}/status.php" | jq -e '.installed==true and .maintenance==false' >/dev/null
            '''
            echo "${OK} Nextcloud OK (installed=true, maintenance=false)"
          }
        }

        stage('Redis') {
          steps {
            script {
              def ok = sh(returnStatus: true, script: '''
                set -e
                if which redis-cli >/dev/null 2>&1; then
                  redis-cli -h "${REDIS_HOST}" -p "${REDIS_PORT}" ping | grep -q PONG
                else
                  echo "TCP check via bash pour Redis..."
                  bash -lc 'exec 3<>/dev/tcp/'"${REDIS_HOST}"'/'"${REDIS_PORT}"' && exec 3>&-'
                fi
              ''') == 0
              if (!ok) error("${env.KO} Redis KO")
              echo "${env.OK} Redis OK"
            }
          }
        }

        stage('Docker Daemon') {
          steps {
            script {
              def ok = sh(returnStatus: true, script: 'docker info >/dev/null 2>&1') == 0
              if (!ok) error("${env.KO} Docker KO")
              sh 'docker ps --format "table {{.Names}}\\t{{.Image}}\\t{{.Status}}" || true'
              echo "${env.OK} Docker OK"
            }
          }
        }

        stage('Jenkins (auto-check)') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://4.233.96.230:8080/login" >/dev/null
            '''
            echo "${OK} Jenkins UI OK"
          }
        }

        stage('Node Exporter') {
          steps {
            sh '''
              set -e
              curl -fsS --max-time 5 "http://127.0.0.1:9100/metrics" | head -5
            '''
            echo "${OK} Node Exporter expose les métriques"
          }
        }

        stage('Grafana') {
          steps {
            script {
              // Attends un credential "Username with password" ID: grafana-admin
              withCredentials([usernamePassword(credentialsId: 'grafana-admin', usernameVariable: 'GF_USER', passwordVariable: 'GF_PASS')]) {
                def st = sh(returnStatus: true, script: '''
                  set -e
                  curl -fsS --max-time 5 -u "${GF_USER}:${GF_PASS}" "http://127.0.0.1:${GRAFANA_PORT}/api/health" | jq -e '.database=="ok"' >/dev/null
                ''')
                if (st != 0) error("${env.KO} Grafana KO (API health)")
                echo "${env.OK} Grafana OK (API health)"
              }
            }
          }
        }

      } // parallel
    }

    stage('Audit rapide des cibles Prometheus') {
      steps {
        sh '''
          set -e
          echo "Targets summary:"

          # 1) Compter les cibles
          curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
            | jq -r '.data.activeTargets | length | "Active targets: " + tostring'

          # 2) Lister job / health / address
          if which column >/dev/null 2>&1; then
            curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
              | jq -r '.data.activeTargets[] | [.labels.job, .health, .discoveredLabels.__address__] | @tsv' \
              | column -t
          else
            curl -fsS "http://127.0.0.1:${PROM_PORT}/api/v1/targets" \
              | jq -r '.data.activeTargets[] | [.labels.job, .health, .discoveredLabels.__address__] | @tsv'
          fi
        '''
        echo "${OK} Audit Prometheus OK"
      }
    }

    stage('Postinstall checks (sanity)') {
      steps {
        sh '''
          echo "Postinstall sanity checks..."
          # Exemple: vérifier que les ports attendus écoutent
          ss -lntp | grep -E ":(${APACHE_PORT}|${PROM_PORT}|${NODEEXP_PORT}|${GRAFANA_PORT}|${JENKINS_PORT})" || true
        '''
        echo "${OK} Postinstall checks terminés"
      }
    }
     stage('Test Slack webhook now') {
      steps {
        withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
          sh '''
            set -e
            # Petit test de connectivité Internet/Slack
            curl -sS https://slack.com/api/api.test >/dev/null

            # Envoi + affichage de la réponse HTTP pour debug
            payload=$(jq -nc --arg t ":rocket: Test webhook depuis ${JOB_NAME} #${BUILD_NUMBER}" \
                           '{text:$t}')
            curl -sS -X POST -H 'Content-type: application/json' \
                 -d "$payload" "$SLACK_URL" \
                 -D /tmp/slack.hdr -o /tmp/slack.out
            echo "---- Slack headers ----"
            cat /tmp/slack.hdr
            echo "---- Slack body ----"
            cat /tmp/slack.out
          '''
        }
      }
    }

    stage('Daily Report') {
      when { triggeredBy 'TimerTrigger' }   // ne tourne que sur déclenchement cron
      steps {
        withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
          sh '''
            set -e
            payload=$(jq -nc --arg t "☀️ Daily Check: ${JOB_NAME} #${BUILD_NUMBER}" '{text:$t}')
            curl -sS -X POST -H 'Content-type: application/json' \
                 -d "$payload" "$SLACK_URL"
          '''
        }
      }
    }
  }
  } // stages

  post {
    success {
      withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
        sh '''
          set -e
          payload=$(jq -nc --arg t "✅ SUCCESS: ${JOB_NAME} #${BUILD_NUMBER}" '{text:$t}')
          curl -sS -X POST -H 'Content-type: application/json' -d "$payload" "$SLACK_URL"
        '''
      }
    }
    failure {
      withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_URL')]) {
        sh '''
          set -e
          payload=$(jq -nc --arg t "❌ FAILURE: ${JOB_NAME} #${BUILD_NUMBER} — check console" '{text:$t}')
          curl -sS -X POST -H 'Content-type: application/json' -d "$payload" "$SLACK_URL"
        '''
      }
    }
  }
  } // pipeline   